#ifndef _CL_SOLVER_HPP_
#define _CL_SOLVER_HPP_

#include "WxIncludeHelper.hpp"
#include "CLIncludeHelper.hpp"
#include "CLTypes.hpp"
#include "Options.hpp"
#include "GLTexture3D.hpp"
#include "GPUContext.hpp"
#include "Utils.hpp"

/**
 * @class CLSolver
 * @brief Manages OpenCL contexts, devices, and kernel execution for fractal calculations.
 *
 * Initializes the OpenCL environment and provides an interface to create and manage
 * OpenCL programs for rendering fractals. Supports OpenCL-OpenGL interop.
 */
class CLSolver {
public:
  /**
   * @class Program
   * @brief Represents an OpenCL program that compiles and executes OpenCL kernels.
   */
  class Program;

  /**
   * @struct Output
   * @brief Stores textures generated by the OpenCL program.
   */
  struct Output {
    /**
     * @brief Constructs Output textures with given dimensions.
     * @param range Dimensions of the textures to create.
     */
    Output(cl::NDRange& range);

    GLTexture3D texture;  ///< Texture storing the main fractal output.
  };

  /**
   * @brief Constructs a CLSolver instance and initializes OpenCL contexts and devices.
   * @param ctx The OpenGL and OpenCL context objects.
   */
  CLSolver(GPUContext& ctx, wxStatusBar& statusBar);

  /**
   * @brief Destructor for the CLSolver, releasing allocated resources.
   */
  ~CLSolver();

  /**
   * @brief Creates and returns a new Program instance associated with this solver.
   * @param space The computation space that this program will use.
   * @return Pointer to the created Program instance.
   */
  Program* createProgram(options::Space space);

private:
  /**
    * @struct Kernels
    * @brief Contains the OpenCL kernel objects.
    */
  struct Kernels {

    template<utils::String kernelName>
    static inline cl::Kernel create(const cl::Program& program);

    /**
     * @struct Space
     * @brief All kernels of a particular computation space (e.g., phase or dynamical).
     */
    struct Space {
      /**
     * @struct RenderMode
     * @brief All kernels of a particular render mode (e.g., escape or translated).
     */
      struct RenderMode {
        cl::Kernel c1;    ///< Kernel reference for the complex number system.
        cl::Kernel c2;    ///< Kernel reference for the bicomplex number system.
        cl::Kernel c3;    ///< Kernel reference for the tricomplex number systems.

        template<utils::String prefix>
        static RenderMode create(const cl::Program& program);

        cl::Kernel& get(options::NumberSystem numberSystem);
      };

      RenderMode escape;            ///< Kernel references for fractional escape color rendering.
      RenderMode translated;        ///< Kernel references for animated point translation of iteration results.

      template<utils::String prefix>
      static Space create(const cl::Program& program);

      RenderMode& get(options::RenderMode renderMode);
    };

    Space phase;                ///< Kernel references for calculations in phase space.
    Space dynamical;            ///< Kernel references for calculations in the dynamical plane.

    Kernels(const cl::Program& program);

    Space& get(options::Space space);
  };

  class Task;
  template <typename T>
  class SVMPtrArray;

  GPUContext& ctx;               ///< OpenGL and OpenCL interface objects.
  cl::Program program;           ///< OpenCL program. Contains all kernels.
  Kernels kernels;               ///< References to the kernels.
};

/**
 * @class CLSolver::Program
 * @brief Compiles and manages execution of OpenCL kernels for fractal calculations.
 */
class CLSolver::Program {
public:
  /**
   * @brief Constructs a Program instance, setting up the OpenCL program and kernel references.
   * @param solver Pointer to the CLSolver instance managing this program.
   */
  Program(CLSolver& solver, Kernels::Space& spaceKernels);

  /**
   * @brief Destructor for the Program class, releasing resources.
   */
  ~Program();

  /**
   * @brief Checks if the program is prepared for execution.
   * @return True if prepared, false otherwise.
   */
  bool isPrepared();

  /**
   * @brief Prepares the program by setting computation dimensions, space, and number system.
   * @param dimensions Dimensions of the computation (2D or 3D).
   * @param resolution Resolution for rendering.
   */
  void prepare(options::Dimensions dimensions, int resolution);

  /**
   * @brief Sets the number system for the task's calculations.
   * @param numberSystem The number system to use.
   */
  void setNumberSystem(options::NumberSystem numberSystem);

  /**
   * @brief Sets the parameters for fractal calculations.
   * @param maxIterations Maximum number of iterations for calculations.
   * @param iterationsPerFrame Iterations performed per frame.
   * @param view The viewspace to apply.
   * @param parameter A parameter for fractal generation.
   */
  void setParameters(int maxIterations, int iterationsPerFrame, cltypes::Viewspace view, cltypes::Number parameter);

  /**
   * @brief Executes the program and returns the generated output.
   * @return Reference to the output containing generated textures.
   */
  Output& execute();

private:
  Program& operator=(Program& rhs);
  friend class CLSolver::Task;

  CLSolver& solver;                   ///< A reference to the parent solver instance.
  Kernels::Space& spaceKernels;       ///< References to the kernels for this program's computation space.
  Task* task;                         ///< Current task for managing execution.
};

/**
 * @class CLSolver::SVMPtrArray
 * @brief Manages Shared Virtual Memory (SVM) pointers for OpenCL device communication.
 * @tparam T Data type for SVM.
 */
template <typename T>
class CLSolver::SVMPtrArray {
public:
  /**
   * @brief Constructs an SVM pointer array.
   * @param ctx OpenCL context.
   * @param queue OpenCL command queue.
   * @param maxMemAllocSize Maximum memory allocatable.
   * @param itemCount Number of items in the array.
   * @param flags Memory flags for SVM.
   * @param alignment Alignment requirement.
   */
  SVMPtrArray(cl::Context& ctx, cl::CommandQueue& queue, size_t maxMemAllocSize, size_t itemCount, cl_svm_mem_flags flags = CL_MEM_READ_WRITE, cl_uint alignment = 0);

  SVMPtrArray(GPUContext& ctx, cl::NDRange& range, cl_svm_mem_flags flags = CL_MEM_READ_WRITE, cl_uint alignment = 0);

  /**
   * @brief Destructor that frees the SVM pointers.
   */
  ~SVMPtrArray();

  /**
   * @brief Sets the SVM pointer as a kernel argument.
   * @param kernel The kernel to set the argument for.
   * @param idx The argument index.
   */
  void setKernelArg(cl::Kernel& kernel, cl_uint idx);

private:
  SVMPtr<T*> ptr;  ///< SVM pointer for shared memory management.
};

/**
 * @class CLSolver::Task
 * @brief Manages execution of OpenCL kernels, facilitating fractal calculation and rendering.
 */
class CLSolver::Task {
public:
  /**
   * @brief Constructs a Task instance with the specified kernels and properties.
   * @param kernelsBySystem The set of kernels based on number system.
   * @param ctx holds the OpenCL interface objects.
   * @param queue Command queue.
   * @param maxMemAllocSize Maximum allocatable memory.
   * @param width Width of the output.
   * @param height Height of the output.
   * @param depth Depth of the output.
   */
  Task(Kernels::Space& spaceKernels, GPUContext& ctx, options::Dimensions dimensions, int resolution);

  /**
   * @brief Destructor for the Task class, releasing allocated resources.
   */
  ~Task();

private:
  Task& operator=(Task& rhs);
  friend class CLSolver::Program;

  /**
   * @brief Executes the task if additional iterations are required.
   * @param queue The OpenCL command queue to use.
   */
  /**
    * @brief Executes the program and returns the generated output.
    * @param queue The OpenCL command queue to use.
    * @return Reference to the output containing generated textures.
    */
  Output& execute(cl::CommandQueue& queue);

  /**
   * @brief Sets the number system kernel for the task.
   * @param program The OpenCL program containing the kernel.
   * @param numberSystem The number system to use.
   */
  void setNumberSystem(cl::Program& program, options::NumberSystem numberSystem);

  /**
   * @brief Sets parameters for the task's fractal calculations.
   * @param maxIterations Maximum iterations.
   * @param iterationsPerFrame Iterations per frame.
   * @param view The viewspace applied.
   * @param parameter Calculation parameter.
   */
  void setParameters(int maxIterations, int iterationsPerFrame, cltypes::Viewspace view, cltypes::Number parameter);
  template <typename T, typename... P>
  static void setKernelParameters(cl::Kernel& kernel, cl_uint idx, T& arg, P&... moreArgs);
  template <typename T>
  static void setKernelParameters(cl::Kernel& kernel, cl_uint idx, T& arg);
  static void setKernelArg(cl::Kernel& kernel, cl_uint idx, SVMPtrArray<cltypes::WorkStore>& arg);
  template <typename T>
  static void setKernelArg(cl::Kernel& kernel, cl_uint idx, T& arg);

  Kernels::Space& spaceKernels;
  cl::Kernel* kernel;
  cl::NDRange range;
  Output output;
  std::vector<cl::Memory> clGlTextures;
  SVMPtrArray<cltypes::WorkStore> buffer;
  cl_uint maxIterations, currentIteration, iterationsPerFrame;
  cltypes::Viewspace view;
  cltypes::Number parameter;
};

#endif